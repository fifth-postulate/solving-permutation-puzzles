# Generators
We have seen that groups are collections of permutations that fit together
nicely. We also have calculated that some groups are very large. For example if
we take the group of all permutation on `n` symbols it has `n!` (`n` factorial)
elements. Factorial grows really fasts as `n` gets bigger. So we are in need of
a more economical way of representing a group. One stop on the way is using
**generators**.

Generators for a group are elements that, when combined together in all possible
ways, will produce every element in the group. Take the group from the *Groups*
chapter. The elements named `b` and `c` together generate the group. To see
this, notice that `a = b^2 = b * b`, `d = b * c`, the only elements of that
group besides `b` and `c`.

## Iterating Elements
One way to use the generators is the iterate over the elements of the generated
group. Iterating over the element is little more than a modified version of
Dijkstra's shortest path algorithm.

The start "vertex" is the identity element. For each "vertex" to visit, the
adjacent "vertices" are the elements that can be reached by multiplying it with
each generator. 

It could be the case that an element is visited multiple times this way. This
can be prevented by maintaining a list of visited elements.

## Membership Test
On question you often would like to see answered is the membership test. In
terms of puzzles, this amounts together

> It it possible to solve this puzzle?

The answer in terms of generators, is this element a member of the generated
group. The exercises help you think about the relation of iterating over the
element and answering the membership question.

## Exercises

1. How many elements has the group generated by

```
[
    0 1 2 3 4
    1 2 3 4 0
]
```

and

```
[
    0 1 2 3 4
    0 4 3 2 1
]
```

2. How many generators does the group that is generated by the following
   element has?
   
```
[
    0 1 2 3 4 5 6
    1 2 3 4 5 6 0
]
```

3. Is the iterating element algorithm helped when the inverses of the generators
   are used as well? If so, how?
4. How does iterating over generated elements can answer the membership
   question?
   
   
## Implementations
Implement an algorithm that will list all permutation elements generated by a
sequence of generators.
